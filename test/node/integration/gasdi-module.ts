/**
 * GasDI - Auto-generated module for Node.js testing
 *
 * ⚠️  DO NOT EDIT THIS FILE MANUALLY
 * This file is automatically generated from:
 * - src/core/modules/GasDI/Core.Types.d.ts
 * - src/core/modules/GasDI/Container.ts
 * - src/core/modules/GasDI/Context.ts
 * - src/core/modules/GasDI/GenericFactory.ts
 * - src/core/modules/GasDI/Decorators.ts
 *
 * To regenerate: npm run build:test-modules
 */

export namespace Ports {
    export type Brand<K, B> = K & { readonly __brand?: B };

    export type Token<T = unknown> = Brand<string, T>;

    export type Lifetime = 'singleton' | 'scoped' | 'transient'

    export interface Factory<T = any> { instantiate(): T }

    export interface Provider<T = any> { (): T }

    export interface Logger { info(msg: string): void; error(msg: string): void }

}

type Lifetime = Ports.Lifetime

type Token<T = any> = Ports.Token<T>

type Register<T = any> =
        | { kind: 'value'; token: Token<T>; value: T }
        | { kind: 'factory'; token: Token<T>; lifetime: Lifetime; make: () => T }

export class Container {
        public static readonly Root = new Container();

        static readonly DEFAULT_SCOPE = 'default';

        private registers = new Map<string, Register<any>>();
        private singletons = new Map<string, any>();
        private scopedByName = new Map<string, Map<string, any>>(); // scopeName -> (token -> instance)
        private parent?: Container;
        private _scopeName?: string;

        constructor(parent?: Container) { this.parent = parent; }

        createScope(name?: string): Container {
            const child: Container = new Container(this);
            (child as any)._scopeName = name && name.trim().length ? name : `request-${Date.now()}`;
            return child;
        }

        registerValue<T>(token: Token<T>, value: T): this {
            this.registers.set(token, { kind: 'value', token, value });
            return this;
        }

        registerFactory<T>(token: Token<T>, make: () => T, lifetime: Lifetime = 'transient'): this {
            this.registers.set(token, { kind: 'factory', token, lifetime, make });
            return this;
        }

        registerClass<T>(token: Token<T>, ctor: new () => T, lifetime: Lifetime = 'transient'): this {
            return this.registerFactory(token, () => new ctor(), lifetime);
        }

        resolve<T>(token: Token<T>, opts?: { optional?: boolean }): T {
            const optional = !!(opts && opts.optional);
            const scopeName = this._scopeName || Container.DEFAULT_SCOPE;
            const got = this.tryResolve<T>(token, scopeName);
            if (got === undefined && !optional) throw new Error(`DI token not found: ${token}`);
            return got as T;
        }

        private tryResolve<T>(token: Token<T>, scopeName: string): T | undefined {
            const reg = this.registers.get(token);
            if (reg) return this.instantiate(reg, scopeName);

            if (this.parent) {
                const parentVal = this.parent.tryResolve<T>(token, scopeName);
                if (parentVal !== undefined) return parentVal;
            }
            return undefined;
        }

        private instantiate<T>(reg: Register<T>, scopeName: string): T {
            if (reg.kind === 'value') return reg.value;

            if (reg.lifetime === 'singleton') {
                if (this.singletons.has(reg.token)) return this.singletons.get(reg.token);
                const v = reg.make();
                this.singletons.set(reg.token, v);
                return v;
            }
            if (reg.lifetime === 'scoped') {
                const name = scopeName || Container.DEFAULT_SCOPE;
                let bag = this.scopedByName.get(name);
                if (!bag) { bag = new Map(); this.scopedByName.set(name, bag); }
                if (bag.has(reg.token)) return bag.get(reg.token);
                const v = reg.make();
                bag.set(reg.token, v);
                return v;
            }
            return reg.make();
        }

        /**
         * Disposes the scoped container and cleans up scoped instances
         * Should be called after GasDI.Context.run to prevent resource leaks
         * Only cleans up resources for scoped containers (those with a scope name)
         *
         * Note: Scoped containers typically don't have their own registrations,
         * they inherit from parent. This method focuses on cleaning up instances.
         */
        dispose(): void {
            if (this._scopeName) {
                // Clear scoped instances for this scope from parent container
                if (this.parent) {
                    this.parent.scopedByName.delete(this._scopeName);
                }
                // Clear local scoped instances
                this.scopedByName.clear();
            }
        }
    }

export class Context {
        private static _current: Container;

        static run<T>(container: Container, fn: () => T): T {
            const prev = this.current;
            Context._current = container;
            try {
                return fn();
            } finally {
                Context._current = prev;
            }
        }

        static get current(): Container {
            return Context._current ?? Container.Root;
        }
    }

export class GenericFactory<T> implements Ports.Factory<T> {
        private readonly ctor: new () => T;
        constructor(ctor: new () => T) { this.ctor = ctor; }
        instantiate(): T { return new this.ctor(); }
    }

export namespace Decorators {
    type Token<T = any> = Ports.Token<T>

    export function Inject(token: Token, optional = false): PropertyDecorator & ParameterDecorator {
        return function (target: any, propertyKey: string | symbol | undefined, paramIndex?: number) {
            if (typeof paramIndex === 'number') {
                const tableKey = propertyKey ? String(propertyKey) : '__ctor__';
                const targetCtor = propertyKey ? target.constructor : target;
                const meta = targetCtor._injectedParams || {};
                const list = meta[tableKey] || [];
                list.push({ index: paramIndex, token, optional });
                meta[tableKey] = list;
                targetCtor._injectedParams = meta;
            } else if (propertyKey) {
                const injects = (target.constructor._inject || []) as any[];
                injects.push({ propertyKey: String(propertyKey), token, optional });
                target.constructor._inject = injects;
            }
        } as any;
    }

    export function Resolve(): ClassDecorator & MethodDecorator {
        return function (target: any, propertyKey?: string | symbol, descriptor?: PropertyDescriptor): any {
            if (descriptor) {
                const original = descriptor.value as (...args: any[]) => any;
                descriptor.value = function (...args: any[]) {
                    const injectedParams = (target.constructor as any)._injectedParams || {};
                    const defs = injectedParams[propertyKey ? String(propertyKey) : ''] || [];
                    for (const d of defs) {
                        if (args[d.index] === undefined) {
                            args[d.index] = Context.current.resolve(d.token, { optional: d.optional });
                        }
                    }
                    return original.apply(this, args);
                };
                return descriptor;
            } else {
                const orig = target;
                return class extends orig {
                    constructor(...args: any[]) {
                        // constructor params
                        const injectedParams = (orig as any)._injectedParams || {};
                        const ctorDefs = injectedParams['__ctor__'] || [];
                        for (const d of ctorDefs) {
                            if (args[d.index] === undefined) {
                                args[d.index] = Context.current.resolve(d.token, { optional: d.optional });
                            }
                        }
                        super(...args);
                        // properties
                        const injects = (orig as any)._inject || [];
                        for (const it of injects) {
                            (this as any)[it.propertyKey] = Context.current.resolve(it.token, { optional: it.optional });
                        }
                        // methods with param injection
                        const keys = Object.keys(injectedParams).filter(k => k !== '__ctor__');
                        for (const k of keys) {
                            const defs = injectedParams[k];
                            const originalMethod = (orig as any).prototype[k];
                            if (typeof originalMethod !== 'function') continue;
                            (this as any)[k] = (...margs: any[]) => {
                                const arr = margs.slice();
                                for (const d of defs) {
                                    if (arr[d.index] === undefined) {
                                        arr[d.index] = Context.current.resolve(d.token, { optional: d.optional });
                                    }
                                }
                                return originalMethod.apply(this, arr);
                            };
                        }
                    }
                };
            }
        };
    }

}


// Compatibility exports for cross-namespace references
export const GasDI = { Container, Context, GenericFactory, Decorators };
