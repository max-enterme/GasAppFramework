/**
 * Repository Engine - Auto-generated module for Node.js testing
 * 
 * ⚠️  DO NOT EDIT THIS FILE MANUALLY
 * This file is automatically generated from:
 * - src/core/modules/Repository/Core.Types.d.ts
 * - src/core/modules/Repository/Engine.ts
 * - src/core/modules/Repository/Adapters.Memory.ts
 * - src/core/modules/Repository/Codec.Simple.ts
 * 
 * To regenerate: npm run build:test-modules
 */

export namespace Ports {
    export interface Schema<TEntity extends object, Key extends keyof TEntity> {
            parameters: (keyof TEntity)[];
            keyParameters: Key[];
            primaryParameter?: Key;
            optionalParameters?: (keyof TEntity)[];
            instantiate(): TEntity;
            fromPartial(p: Partial<TEntity>): TEntity;
            onBeforeSave?(e: TEntity): TEntity;
            onAfterLoad?(raw: any): TEntity;
            schemaVersion?: number;
        }

    export interface KeyCodec<TEntity extends object, Key extends keyof TEntity> {
            stringify(key: Pick<TEntity, Key>): string;
            parse(s: string): Pick<TEntity, Key>;
        }

    export interface Store<TEntity extends object> {
            load(): { rows: TEntity[] };
            saveAdded(rows: TEntity[]): void;
            saveUpdated(rows: { index: number; row: TEntity }[]): void;
            deleteByIndexes(indexes: number[]): void;
        }

}

export interface Repository<TEntity extends object, Key extends keyof TEntity> {
        load(): void;
        find(key: Pick<TEntity, Key>): TEntity | null;
        findAll(keys: Pick<TEntity, Key>[]): TEntity[];
        upsert(input: Partial<TEntity> | Partial<TEntity>[]): { added: TEntity[]; updated: TEntity[] };
        delete(keys: Pick<TEntity, Key> | Pick<TEntity, Key>[]): { deleted: number };
        readonly entities: TEntity[];
    }

export namespace Engine {
    type Idx = Map<string, number>

    export function create<TEntity extends object, Key extends keyof TEntity>(deps: {
        schema: Repository.Ports.Schema<TEntity, Key>
        store: Repository.Ports.Store<TEntity>
        keyCodec: Repository.Ports.KeyCodec<TEntity, Key>
        logger?: Shared.Types.Logger
    }): Repository<TEntity, Key> {
        const logger = deps.logger ?? { info: (_: string) => { }, error: (_: string) => { } };
        let rows: TEntity[] = [];
        let idx: Idx = new Map();

        /**
         * Extract key from entity based on schema key parameters
         */
        const keyOf = (e: TEntity): Pick<TEntity, Key> => {
            const key: any = {};
            for (const param of deps.schema.keyParameters) {
                key[param as string] = (e as any)[param as string];
            }
            return key;
        };

        /**
         * Serialize key to string for indexing
         */
        const keyToString = (key: Pick<TEntity, Key>): string => {
            return deps.keyCodec.stringify(key);
        };

        /**
         * Rebuild index from current rows
         */
        const buildIndex = () => {
            idx = new Map();
            for (let i = 0; i < rows.length; i++) {
                const key = keyToString(keyOf(rows[i]));
                idx.set(key, i);
            }
        };

        /**
         * Load entities from store and build index
         */
        function load(): void {
            const read = deps.store.load();
            rows = read.rows.map(row => {
                const entity = deps.schema.onAfterLoad ? deps.schema.onAfterLoad(row) : (row as any as TEntity);
                return coerceToSchema(entity);
            });
            buildIndex();
            logger.info(`[Repository] loaded ${rows.length} rows`);
        }

        /**
         * Coerce partial entity to full entity using schema
         */
        function coerceToSchema(partial: Partial<TEntity>): TEntity {
            const entity = deps.schema.fromPartial(partial);
            return deps.schema.onBeforeSave ? deps.schema.onBeforeSave(entity) : entity;
        }

        function find(key: Pick<TEntity, Key>): TEntity | null {
            ensureLoaded();
            const i = idx.get(keyToString(key));
            return i == null ? null : rows[i];
        }

        function findAll(keys: Pick<TEntity, Key>[]): TEntity[] {
            ensureLoaded();
            const out: TEntity[] = [];
            for (const k of keys) {
                const i = idx.get(keyToString(k));
                if (i != null) out.push(rows[i]);
            }
            return out;
        }

        /**
         * Insert or update entities
         */
        function upsert(input: Partial<TEntity> | Partial<TEntity>[]): { added: TEntity[]; updated: TEntity[] } {
            ensureLoaded();
            const items = Array.isArray(input) ? input : [input];
            const added: TEntity[] = [];
            const updated: TEntity[] = [];
            const forStoreAdds: TEntity[] = [];
            const forStoreUpdates: { index: number; row: TEntity }[] = [];

            for (const partial of items) {
                const entity = coerceToSchema(partial);
                const key = keyOf(entity);
                validateKey(key);
                
                const keyStr = keyToString(key);
                const existingIndex = idx.get(keyStr);
                
                if (existingIndex == null) {
                    // Add new entity
                    const newIndex = rows.length;
                    rows.push(entity);
                    idx.set(keyStr, newIndex);
                    added.push(entity);
                    forStoreAdds.push(entity);
                } else {
                    // Update existing entity
                    rows[existingIndex] = entity;
                    updated.push(entity);
                    forStoreUpdates.push({ index: existingIndex, row: entity });
                }
            }

            // Persist changes to store
            if (forStoreAdds.length > 0) deps.store.saveAdded(forStoreAdds);
            if (forStoreUpdates.length > 0) deps.store.saveUpdated(forStoreUpdates);
            
            return { added, updated };
        }

        /**
         * Delete entities by keys
         */
        function deleteMany(keys: Pick<TEntity, Key> | Pick<TEntity, Key>[]): { deleted: number } {
            ensureLoaded();
            const keyList = Array.isArray(keys) ? keys : [keys];
            const indicesToDelete: number[] = [];
            
            // Find all entities to delete
            for (const key of keyList) {
                const index = idx.get(keyToString(key));
                if (index != null) {
                    indicesToDelete.push(index);
                }
            }
            
            if (indicesToDelete.length === 0) return { deleted: 0 };
            
            // Sort indexes for consistent deletion
            indicesToDelete.sort((a, b) => a - b);
            
            // Mark rows to keep
            const keepRow = new Array(rows.length).fill(true);
            for (const index of indicesToDelete) {
                keepRow[index] = false;
            }
            
            // Compact rows array
            const newRows: TEntity[] = [];
            for (let i = 0; i < rows.length; i++) {
                if (keepRow[i]) newRows.push(rows[i]);
            }
            
            rows = newRows;
            buildIndex();
            deps.store.deleteByIndexes(indicesToDelete);
            
            return { deleted: indicesToDelete.length };
        }

        /**
         * Ensure data is loaded before operations
         */
        function ensureLoaded() {
            if (rows.length === 0 && idx.size === 0) load();
        }

        /**
         * Validate that all key parts are present
         */
        function validateKey(key: Pick<TEntity, Key>) {
            for (const param of deps.schema.keyParameters) {
                const value = (key as any)[param as string];
                if (value == null || value === '') {
                    throw new Repository.RepositoryError('InvalidKey', `key part "${String(param)}" is missing`);
                }
            }
        }

        const result = {
            load,
            find,
            findAll,
            upsert,
            delete: deleteMany,
            get entities() {
                ensureLoaded();
                return rows;
            }
        };

        return result;
    }

}

export namespace Adapters.Memory {
    export class Store<TEntity extends object> implements Repository.Ports.Store<TEntity> {
        private arr: TEntity[] = [];

        /**
         * Load all entities from memory
         */
        load(): { rows: TEntity[] } {
            return { rows: this.arr.slice() };
        }

        /**
         * Append new entities to the end of the array
         */
        saveAdded(rows: TEntity[]): void {
            this.arr.push(...rows);
        }

        /**
         * Update entities at specific indexes
         */
        saveUpdated(rows: { index: number; row: TEntity }[]): void {
            for (const r of rows) {
                this.arr[r.index] = r.row;
            }
        }

        /**
         * Delete entities by marking and compacting the array
         */
        deleteByIndexes(indexes: number[]): void {
            const keepRow = new Array(this.arr.length).fill(true);
            
            // Mark rows to delete
            for (const idx of indexes) {
                keepRow[idx] = false;
            }
            
            // Compact array by keeping only marked rows
            const newArr: TEntity[] = [];
            for (let i = 0; i < this.arr.length; i++) {
                if (keepRow[i]) newArr.push(this.arr[i]);
            }
            
            this.arr = newArr;
        }
    }

}

export namespace Codec {
    export function simple<TEntity extends object, Key extends keyof TEntity>(delim = '|') {
        /**
         * Escape special characters (backslash and delimiter)
         */
        const delimRegex = new RegExp(`[${delim}]`, 'g');
        const escape = (s: string): string => 
            s.replace(/\\/g, '\\\\').replace(delimRegex, match => '\\' + match);
        
        return {
            /**
             * Convert key object to delimited string
             */
            stringify(key: any): string {
                const parts: string[] = [];
                const keys = Object.keys(key);
                
                for (const k of keys) {
                    const value = key[k];
                    const stringValue = value == null ? '' : String(value);
                    parts.push(escape(stringValue));
                }
                
                return parts.join(delim);
            },
            
            /**
             * Parse delimited string back to array of values
             * Note: Returns array - caller must map back to key object
             */
            parse(s: string): any {
                const parts: string[] = [];
                let current = '';
                
                for (let i = 0; i < s.length; i++) {
                    const char = s[i];
                    
                    // Handle escape sequences
                    if (char === '\\' && i + 1 < s.length) {
                        current += s[i + 1];
                        i++;
                    } else if (char === delim) {
                        // Delimiter: push current part and start new one
                        parts.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                parts.push(current);
                return parts;
            }
        } as Repository.Ports.KeyCodec<TEntity, Key> as any;
    }

}


// Compatibility exports for existing tests
export const MemoryStore = Adapters.Memory.Store;
export const createSimpleCodec = Codec.simple;
export const createRepository = Engine.create;
